import OpenAI from 'openai';
import axios from 'axios';
import path from 'path';
import fs from 'fs';
import os from 'os';
import sharp from 'sharp';
import FormData from 'form-data';

// Set environment-specific timeouts
const IS_PRODUCTION = process.env.NODE_ENV === 'production';
const API_TIMEOUT = IS_PRODUCTION ? 300000 : 600000; // 5 minutes in production, 10 minutes in development

// Initialize OpenAI client with timeout
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
  timeout: API_TIMEOUT,
  maxRetries: 2, // Add retry capability
});

// Control how image enhancement works with environment variables
const ENHANCEMENT_TIMEOUT = parseInt(process.env.ENHANCEMENT_TIMEOUT || '45000', 10); // 45 seconds default
const SKIP_LOCAL_FILES = process.env.SKIP_LOCAL_FILES === 'true';

// Function to create a timeout promise that rejects after a specified time
function timeout(ms: number): Promise<never> {
  return new Promise((_, reject) => {
    setTimeout(() => reject(new Error(`Operation timed out after ${ms}ms`)), ms);
  });
}

/**
 * Enhance a Pokemon fusion image generated by Stable Diffusion
 * This uses a generic prompt to improve the image while avoiding content policy issues
 */
export async function enhanceWithDirectGeneration(
  pokemon1Name: string,
  pokemon2Name: string,
  imageSource?: string | { remoteUrl: string, localUrl: string | null }
): Promise<string | null> {
  const requestId = `dalle-enhance-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
  const startTime = Date.now();
  
  // Extract remote and local URLs from input
  let remoteImageUrl: string | null = null;
  let localImagePath: string | null = null;
  
  if (imageSource) {
    if (typeof imageSource === 'string') {
      // Legacy format - just a URL
      remoteImageUrl = imageSource;
    } else {
      // New format - object with remoteUrl and localUrl
      remoteImageUrl = imageSource.remoteUrl;
      localImagePath = imageSource.localUrl;
    }
  }
  
  // Force log this message to ensure it's visible in production
  console.warn(`[${requestId}] DALLE ENHANCEMENT - START - ${pokemon1Name} + ${pokemon2Name} at ${new Date().toISOString()}`);
  console.log(`[${requestId}] DALLE ENHANCEMENT - Image sources: remote=${remoteImageUrl?.substring(0, 30)}..., local=${localImagePath}`);
  
  // If we have an image source and no OpenAI API key, just return the original image
  if (remoteImageUrl && !process.env.OPENAI_API_KEY) {
    console.warn(`[${requestId}] DALLE ENHANCEMENT - SKIPPED - No OpenAI API key, using original image directly`);
    return remoteImageUrl;
  }
  
  // Check that OpenAI API key is properly formatted
  if (process.env.OPENAI_API_KEY && !process.env.OPENAI_API_KEY.startsWith('sk-')) {
    console.error(`[${requestId}] DALLE ENHANCEMENT - ERROR - Invalid OpenAI API key format`);
    // Return the original image if we have it
    if (remoteImageUrl) {
      console.warn(`[${requestId}] DALLE ENHANCEMENT - SKIPPED - Using original image due to API key format issue`);
      return remoteImageUrl;
    }
    return null;
  }
  
  // Check that environment flag is enabled
  if (process.env.USE_GPT_VISION_ENHANCEMENT !== 'true') {
    console.warn(`[${requestId}] DALLE ENHANCEMENT - SKIPPED - Enhancement feature is disabled`);
    // Return the original image if we have it
    if (remoteImageUrl) {
      console.warn(`[${requestId}] DALLE ENHANCEMENT - Using original image directly (enhancement disabled)`);
      return remoteImageUrl;
    }
    return null;
  }
  
  console.log(`[${requestId}] DALLE ENHANCEMENT - API Key check: ${process.env.OPENAI_API_KEY ? `present (${process.env.OPENAI_API_KEY.length} chars)` : 'missing'}`);
  
  try {
    // Create a timeout controller for axios requests
    const controller = new AbortController();
    const timeoutId = setTimeout(() => {
      controller.abort();
      console.warn(`[${requestId}] DALLE ENHANCEMENT - Request aborted due to timeout after ${ENHANCEMENT_TIMEOUT}ms`);
    }, ENHANCEMENT_TIMEOUT);
    
    try {
      // Force log this to ensure it appears in production logs
      console.warn(`[${requestId}] DALLE ENHANCEMENT - API CALL STARTING at ${new Date().toISOString()}`);
      
      let response;
      
      // Check if we have a local file to use and local files aren't being skipped
      // Add extra validation to ensure the file exists
      const actualLocalPath = localImagePath ? path.join(process.cwd(), 'public', localImagePath) : null;
      const hasLocalFile = !SKIP_LOCAL_FILES && 
                         actualLocalPath && 
                         fs.existsSync(actualLocalPath) && 
                         fs.statSync(actualLocalPath).size > 0;
      
      if (hasLocalFile && actualLocalPath) {
        // We have a local file, use image editing instead of direct generation
        console.log(`[${requestId}] DALLE ENHANCEMENT - Using local file for enhancement: ${localImagePath} (${fs.statSync(actualLocalPath).size} bytes)`);
        
        try {
          // Read the local file
          const imageBuffer = fs.readFileSync(actualLocalPath);
          
          // Image editing prompt - more tailored to enhance existing image
          const enhancementPrompt = `Enhance this Pokemon fusion of ${pokemon1Name} and ${pokemon2Name}. 
            Make it more vibrant with clean animation-style outlines, maintain kid-friendly appearance, 
            and ensure completely pure white background. Improve the fusion design while keeping the 
            same pose and overall characteristics.`;
          
          console.log(`[${requestId}] DALLE ENHANCEMENT - Using image editing with prompt`);
          
          // Set up form data for the API call
          const formData = new FormData();
          
          formData.append('prompt', enhancementPrompt);
          formData.append('n', '1');
          formData.append('size', '1024x1024');
          formData.append('model', 'gpt-image-1');
          
          // Add the image
          formData.append('image', imageBuffer, {
            filename: 'pokemon-fusion.png',
            contentType: 'image/png',
          });
          
          // Make the API call using axios with a Promise.race for additional timeout protection
          const editPromise = axios.post(
            'https://api.openai.com/v1/images/edits',
            formData,
            {
              headers: {
                'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
                ...formData.getHeaders(),
              },
              timeout: ENHANCEMENT_TIMEOUT * 0.6, // Use 60% of timeout for API call
              signal: controller.signal
            }
          );
          
          const editResponse = await Promise.race([
            editPromise,
            timeout(ENHANCEMENT_TIMEOUT * 0.7) // Slightly longer than axios timeout
          ]).catch(timeoutErr => {
            console.error(`[${requestId}] DALLE ENHANCEMENT - Edit request timed out: ${timeoutErr.message}`);
            // Rethrow with a specific message
            throw new Error(`Image editing timed out after ${ENHANCEMENT_TIMEOUT * 0.7}ms`);
          });
          
          // Convert the response to the expected format
          response = {
            data: editResponse.data.data
          };
          
          console.log(`[${requestId}] DALLE ENHANCEMENT - Image editing API call successful`);
        } catch (editError) {
          console.error(`[${requestId}] DALLE ENHANCEMENT - Error with image editing:`, 
            editError instanceof Error ? {
              message: editError.message,
              name: editError.name,
              stack: editError.stack?.split('\n')[0]
            } : editError
          );
          
          if (editError instanceof Error && 
             (editError.message.includes('timeout') || 
              editError.message.includes('abort') || 
              editError.message.includes('aborted'))) {
            console.warn(`[${requestId}] DALLE ENHANCEMENT - Request timed out or was aborted, using original image`);
            return remoteImageUrl;
          }
          
          // Fall back to text-to-image generation if editing fails
          console.log(`[${requestId}] DALLE ENHANCEMENT - Falling back to text-to-image generation`);
          response = await performTextToImageGeneration(requestId, pokemon1Name, pokemon2Name, controller);
        }
      } else {
        // If no local file, use text-to-image generation
        if (actualLocalPath) {
          console.log(`[${requestId}] DALLE ENHANCEMENT - Local file validation failed:
            Path: ${actualLocalPath}
            Exists: ${fs.existsSync(actualLocalPath)}
            Size: ${fs.existsSync(actualLocalPath) ? fs.statSync(actualLocalPath).size : 'N/A'} bytes
            SKIP_LOCAL_FILES: ${SKIP_LOCAL_FILES}`
          );
        } else {
          console.log(`[${requestId}] DALLE ENHANCEMENT - No local file path provided`);
        }
        
        console.log(`[${requestId}] DALLE ENHANCEMENT - Using text-to-image generation`);
        response = await performTextToImageGeneration(requestId, pokemon1Name, pokemon2Name, controller);
      }
      
      // Clear the timeout since we're done with the API call
      clearTimeout(timeoutId);
      
      const requestDuration = Date.now() - startTime;
      console.warn(`[${requestId}] DALLE ENHANCEMENT - API CALL COMPLETED in ${requestDuration}ms`);
      
      if (!response?.data || response.data.length === 0) {
        console.error(`[${requestId}] DALLE ENHANCEMENT - ERROR: Empty response data`);
        return remoteImageUrl;
      }

      // Handle the response (URL or base64)
      if (response.data[0]?.url) {
        const imageUrl = response.data[0].url;
        console.warn(`[${requestId}] DALLE ENHANCEMENT - SUCCESS: Generated URL: ${imageUrl.substring(0, 50)}...`);
        
        // Try to delete the local source image if available
        if (hasLocalFile && actualLocalPath) {
          try {
            deleteLocalImage(actualLocalPath, requestId);
          } catch (deleteError) {
            // Non-critical error, just log it
            console.error(`[${requestId}] DALLE ENHANCEMENT - Failed to delete local image: ${deleteError}`);
          }
        }
        
        return imageUrl;
      }

      console.error(`[${requestId}] DALLE ENHANCEMENT - No image URL in response data`);
      return remoteImageUrl;
    } catch (error) {
      clearTimeout(timeoutId);
      
      // Check for organization verification error
      if (error instanceof Error && 
          error.message && 
          error.message.includes('organization verification')) {
        console.error(`[${requestId}] DALLE ENHANCEMENT - Organization verification required. Please visit: https://help.openai.com/en/articles/10910291-api-organization-verification`);
      }

      // Check for content policy violation
      if (error instanceof Error && 
          (error.message?.includes('content policy') || error.message?.includes('safety system'))) {
        console.error(`[${requestId}] DALLE ENHANCEMENT - Content policy violation: The request was rejected by the moderation system`);
      }
      
      // Check for timeout or aborted requests
      if (error instanceof Error && 
          (error.message?.includes('timeout') || 
           error.message?.includes('abort') || 
           error.message?.includes('aborted'))) {
        console.error(`[${requestId}] DALLE ENHANCEMENT - Request timed out or was aborted: ${error.message}`);
      }
      
      console.error(`[${requestId}] DALLE ENHANCEMENT - Error:`, error);
      return remoteImageUrl;
    }
  } catch (error) {
    console.error(`[${requestId}] DALLE ENHANCEMENT - Unexpected error:`, error);
    return remoteImageUrl;
  }
}

/**
 * Helper function to perform text-to-image generation
 */
async function performTextToImageGeneration(
  requestId: string,
  pokemon1Name: string,
  pokemon2Name: string,
  controller: AbortController
): Promise<any> {
  // This is our most reliable prompt that works consistently with content policies
  const enhancementPrompt = `A digital illustration of an original animated creature design combining traits of ${pokemon1Name} and ${pokemon2Name}.
    The creature is a fusion of these two PokÃ©mon species with balanced features from both.
    Style: Clean animation with smooth outlines, kid friendly
    Background: Pure white
    Composition: Single character centered in the frame
    Details: Balanced proportions, friendly appearance, polished finish`;
  
  console.log(`[${requestId}] DALLE ENHANCEMENT - Generating image with text-to-image prompt`);

  // Generate a new image using GPT-image-1
  try {
    // Use Promise.race to add an additional timeout layer
    return await Promise.race([
      openai.images.generate({
        model: "gpt-image-1",
        prompt: enhancementPrompt,
        n: 1,
        size: "1024x1024"
      }),
      timeout(ENHANCEMENT_TIMEOUT * 0.8) // 80% of the main timeout
    ]).catch(err => {
      console.error(`[${requestId}] DALLE ENHANCEMENT - Text-to-image generation failed: ${err.message}`);
      throw new Error(`Text-to-image generation timed out: ${err.message}`);
    });
  } catch (error) {
    console.error(`[${requestId}] DALLE ENHANCEMENT - Text-to-image generation error:`, 
      error instanceof Error ? {
        message: error.message,
        name: error.name,
        stack: error.stack?.split('\n')[0]
      } : error
    );
    
    // Re-throw to allow the caller to handle
    throw error;
  }
}

/**
 * Generate a Pokemon fusion using image editing approach
 * This function is kept for backward compatibility but modified to work with current API
 */
export async function generatePokemonFusion(
  image1: string,
  image2: string,
  maskType: 'lower-half' | 'upper-half' | 'right-half' | 'left-half'
): Promise<string | null> {
  console.log('GPT Image Editing - Starting fusion with images');
  
  // This function is not currently implemented
  // Return null to allow fallback to other methods
  return null;
}

/**
 * Legacy function - kept for backward compatibility
 */
export async function enhanceImageWithGptVision(): Promise<string | null> {
  console.log('GPT Direct Enhancement - enhanceImageWithGptVision is deprecated');
  return null;
}

/**
 * Helper function to delete a local image file
 */
function deleteLocalImage(filePath: string, requestId: string): void {
  if (fs.existsSync(filePath)) {
    fs.unlinkSync(filePath);
    console.log(`[${requestId}] DALLE ENHANCEMENT - Deleted local image at: ${filePath}`);
  } else {
    console.log(`[${requestId}] DALLE ENHANCEMENT - Local image not found: ${filePath}`);
  }
} 